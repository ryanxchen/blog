exports.ids = [3];
exports.modules = {

/***/ 40:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const prism = __webpack_require__(38);

function wrap(code, lang) {
  return `<pre class="language-${lang}"><code>${code}</code></pre>`;
}

function highlight(str, lang) {
  if (!lang) {
    return wrap(str, 'text');
  }

  const rawLang = lang;

  if (lang === 'vue' || lang === 'html') {
    lang = 'markup';
  }

  if (lang === 'md') {
    lang = 'markdown';
  }

  if (prism.languages[lang]) {
    const code = prism.highlight(str, prism.languages[lang], lang);
    return wrap(code, rawLang);
  }

  return wrap(str, 'text');
}

/* harmony default export */ __webpack_exports__["a"] = (__webpack_require__(39)({
  html: true,
  typographer: true,
  highlight
}));

/***/ }),

/***/ 41:
/***/ (function(module) {

module.exports = JSON.parse("[{\"_id\":\"5ce411cb9ae55c41e3feed98\",\"meta\":{\"createDate\":\"2019-05-21 22:57:15\",\"updateDate\":\"2019-05-21 22:59:01\"},\"tags\":[\"vue\"],\"title\":\"vue源码阅读之响应式原理\",\"content\":\"Vue 中对数据的响应式，即对 `props`、`data`、`computed` 的变化进行响应式更改。\\n\\n其入口是在 `src/core/instance/init.js` 里的 `initState(vm)` 里进行实现的。\\n\\n`initState(vm)` 里 初始化了 `props`, `methods`, `data`, `computed`, `watch`。\\n\\n### initData\\n\\n从 `initData` 入手来看下：\\n```js\\nfunction initData (vm: Component) {\\n  let data = vm.$options.data\\n  // 将_data作为中间变量，后续 proxy 里会用到\\n  data = vm._data = typeof data === 'function'\\n    ? getData(data, vm) // getData 做了错误处理，并控制了 Dep.target，使得避免在获取 data 初始值的过程中意外地把依赖记录下来。\\n    : data || {}\\n  // 省略相关 warn 代码...\\n  // 进行 data proxy methods 重复 key 的检验并抛出 warn msg\\n  // proxy data on instance\\n  const keys = Object.keys(data)\\n  const props = vm.$options.props\\n  const methods = vm.$options.methods\\n  let i = keys.length\\n  while (i--) {\\n    const key = keys[i]\\n    // 省略相关关于重复 key 检测 warn 代码\\n    // 对 _data 对象上的每个 key 进行 getter setter 设置\\n    // 使得访问 this.xxx 代理到 this._data.xxx\\n    proxy(vm, `_data`, key)\\n  }\\n  // observe data\\n  /**\\n   * 响应式核心方法\\n   * 即 new Observer(value)\\n   * 具体看 new Observer(value) 逻辑\\n   * */\\n  observe(data, true /* asRootData */)\\n}\\n```\\n\\n`initData` 里首先将原始 data 复制了份 _data，然后遍历了每个 key，\\n通过 `proxy` 方法对 _data 里的 key 进行了 getter setter 设置。\\n\\n使得访问 this.xxx 代理到 this._data.xxx。\\n\\n接下来执行 `observe(data, true /* asRootData */)`。\\n\\n该方法结果是 `return new Observer(value)`，返回了一个 `Observer` 实例。\\n### Observer\\n来看下 `Observer` 类的定义，这也是响应式实现的主要地方。\\n\\n<details>\\n  <summary>class Observer 源码</summary>\\n\\n  ```js\\n  export class Observer {\\n    value: any;\\n    dep: Dep;\\n    vmCount: number; // number of vms that has this object as root $data\\n\\n    constructor (value: any) {\\n      this.value = value\\n      this.dep = new Dep()\\n      this.vmCount = 0\\n      // 添加 __ob__ 属性，值为自身，即 this.data.__ob__ = this\\n      def(value, '__ob__', this)\\n      if (Array.isArray(value)) {\\n        // 对数组原生方法进行了劫持，使得push 等能监控到，来触发响应式，但无法监控到 通过下标更改的情况\\n        if (hasProto) {\\n          protoAugment(value, arrayMethods)\\n        } else {\\n          copyAugment(value, arrayMethods, arrayKeys)\\n        }\\n        // 对数组进行遍历执行 observe\\n        this.observeArray(value)\\n      } else {\\n        // 会进入 walk 方法\\n        this.walk(value)\\n      }\\n    }\\n\\n    /**\\n     * Walk through each property and convert them into\\n     * getter/setters. This method should only be called when\\n     * value type is Object.\\n     */\\n    walk (obj: Object) {\\n      const keys = Object.keys(obj)\\n      for (let i = 0; i < keys.length; i++) {\\n        // 通过 defineReactive 方法，设置 getter setter, 真正的响应代码\\n        defineReactive(obj, keys[i])\\n      }\\n    }\\n\\n    /**\\n     * Observe a list of Array items.\\n     */\\n    observeArray (items: Array<any>) {\\n      for (let i = 0, l = items.length; i < l; i++) {\\n        observe(items[i])\\n      }\\n    }\\n  }\\n  ```\\n</details>\\n\\n`Observer` 在 new 的时候，主要逻辑会先执行 `this.dep = new Dep()` 来创建依赖实例，然后处理数组/对象的情况。\\n\\n这中间还对里面的每个元素进行了深度遍历，使得每个元素均是响应式的。\\n\\n再主要来看 `this.walk(value)` 方法，该方法通过 `defineReactive` 方法，设置 getter setter，这是真正的响应代码。\\n<details>\\n  <summary>defineReactive 源码</summary>\\n\\n  ```js\\n  export function defineReactive (\\n    obj: Object,\\n    key: string,\\n    val: any,\\n    customSetter?: ?Function,\\n    shallow?: boolean\\n  ) {\\n    // 缓存依赖\\n    const dep = new Dep()\\n\\n    const property = Object.getOwnPropertyDescriptor(obj, key)\\n    if (property && property.configurable === false) {\\n      return\\n    }\\n\\n    // cater for pre-defined getter/setters\\n    // 这里代码类比 computed 里属性定义的 getter setter 那样\\n    // 定义了，就用定义的 getter setter 方法\\n    const getter = property && property.get\\n    const setter = property && property.set\\n    if ((!getter || setter) && arguments.length === 2) {\\n      val = obj[key]\\n    }\\n    // childObserve 对象，对 child 进行监听\\n    let childOb = !shallow && observe(val)\\n    Object.defineProperty(obj, key, {\\n      enumerable: true,\\n      configurable: true,\\n      // 这步主要收集依赖，并返回值\\n      get: function reactiveGetter () {\\n        // 兼容使用定义的 getter 情况\\n        const value = getter ? getter.call(obj) : val\\n        if (Dep.target) {\\n          dep.depend()\\n          if (childOb) {\\n            childOb.dep.depend()\\n            if (Array.isArray(value)) {\\n              dependArray(value)\\n            }\\n          }\\n        }\\n        return value\\n      },\\n      // 这步触发依赖并设置值\\n      set: function reactiveSetter (newVal) {\\n        const value = getter ? getter.call(obj) : val\\n        /* eslint-disable no-self-compare */\\n        if (newVal === value || (newVal !== newVal && value !== value)) {\\n          return\\n        }\\n        /* eslint-enable no-self-compare */\\n        if (process.env.NODE_ENV !== 'production' && customSetter) {\\n          customSetter()\\n        }\\n        // #7981: for accessor properties without setter\\n        if (getter && !setter) return\\n        // 自己定义了 setter 就调用自己的 setter, 没有就直接赋值\\n        if (setter) {\\n          setter.call(obj, newVal)\\n        } else {\\n          val = newVal\\n        }\\n        // newVal 是个 object，则继续递归执行监听 observe\\n        childOb = !shallow && observe(newVal)\\n        // 触发更新\\n        dep.notify()\\n      }\\n    })\\n  }\\n  ```\\n</details>\\n\\n`defineReactive` 代码可以简化如下：\\n```js\\n_defineReactive (obj, key, val) {\\n  const dep = new Dep()\\n  Object.defineProperty(obj, key, {\\n    configurable: true,\\n    enumerable: true,\\n    get: function reactiveGetter() {\\n      dep.addSub(Dep.target)\\n      return val\\n    },\\n    set: function reactiveSetter(newVal) {\\n      const value = getter ? getter.call(obj) : val\\n      if (newVal === value) return\\n      // 自己定义了 setter 就调用自己的 setter, 没有就直接赋值\\n      if (setter) {\\n        setter.call(obj, newVal)\\n      } else {\\n        val = newVal\\n      }\\n      dep.notify()\\n    }\\n  })\\n}\\n```\\n在 `defineReactive` 函数内，通过闭包实例化了 `Dep` 这个订阅者。\\n\\n### Dep\\n\\n<details>\\n  <summary>class Dep 源码</summary>\\n\\n  ```js\\n  export default class Dep {\\n    static target: ?Watcher;\\n    id: number;\\n    subs: Array<Watcher>;\\n\\n    constructor () {\\n      this.id = uid++\\n      this.subs = []\\n    }\\n\\n    addSub (sub: Watcher) {\\n      this.subs.push(sub)\\n    }\\n\\n    removeSub (sub: Watcher) {\\n      remove(this.subs, sub)\\n    }\\n\\n    depend () {\\n      if (Dep.target) {\\n        // Dep.target 即 watcher：watcher.addDep(dep)\\n        Dep.target.addDep(this)\\n      }\\n    }\\n\\n    notify () {\\n      // stabilize the subscriber list first\\n      const subs = this.subs.slice()\\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\\n        // subs aren't sorted in scheduler if not running async\\n        // we need to sort them now to make sure they fire in correct\\n        // order\\n        subs.sort((a, b) => a.id - b.id)\\n      }\\n      for (let i = 0, l = subs.length; i < l; i++) {\\n        subs[i].update()\\n      }\\n    }\\n  }\\n\\n  // the current target watcher being evaluated.\\n  // this is globally unique because there could be only one\\n  // watcher being evaluated at any time.\\n  // 保存当前全局唯一存在的 watcher\\n  Dep.target = null\\n  const targetStack = []\\n\\n  export function pushTarget (_target: ?Watcher) {\\n    if (Dep.target) targetStack.push(Dep.target)\\n    Dep.target = _target\\n  }\\n\\n  export function popTarget () {\\n    Dep.target = targetStack.pop()\\n  }\\n  ```\\n</details>\\n\\n`Dep` 这里可以简化为：\\n```js\\nclass Dep {\\n  constructor() {\\n    this.subs = []\\n  }\\n  addSub(sub) {\\n    this.subs.push(sub)\\n  }\\n  notify() {\\n    this.subs.forEach(sub => {\\n      sub.update()\\n    })\\n  }\\n}\\n\\nDep.target = null\\n```\\n`Dep` 这个依赖订阅者，有自己的 `subs` 用来缓存 `Dep.target`，`Dep.target` 其实是一个 watcher 实例，这里先不管 watcher。\\n回到 `defineReactive`，在 get 里将 watcher 实例添加到订阅者 Dep 里，\\n在 set 时遍历缓存在 dep.subs 数组里的 watcher 实例，执行 `watcher.update()` 方法，来触发更新。\\n\\n### Watcher\\n来看下 class Watcher\\n\\n<details>\\n  <summary>class Watcher 源码</summary>\\n\\n  ```js\\n    export default class Watcher {\\n      vm: Component; // 实例自身\\n      expression: string;\\n      cb: Function;\\n      id: number;\\n      deep: boolean;\\n      user: boolean;\\n      lazy: boolean;\\n      sync: boolean;\\n      dirty: boolean;\\n      active: boolean;\\n      deps: Array<Dep>;\\n      newDeps: Array<Dep>;\\n      depIds: SimpleSet; // ES6 set 类型\\n      newDepIds: SimpleSet; // ES6 set 类型\\n      before: ?Function;\\n      getter: Function;\\n      value: any;\\n\\n      constructor (\\n        vm: Component,\\n        expOrFn: string | Function, // 表达式本身 [ getter | noop ]\\n        cb: Function, // [ noop ]\\n        options?: ?Object, // { lazy: true } // 如果设置为 true 则在第一次 get 的时候才计算值，初始化的时候并不计算。init 时为 true\\n        isRenderWatcher?: boolean\\n      ) {\\n        this.vm = vm\\n        if (isRenderWatcher) {\\n          vm._watcher = this\\n        }\\n        vm._watchers.push(this)\\n        // options\\n        if (options) {\\n          this.deep = !!options.deep\\n          this.user = !!options.user\\n          this.lazy = !!options.lazy\\n          this.sync = !!options.sync\\n          /*\\n          before作用是定义 beforeUpdate 钩子：\\n          「\\n            before () {\\n                if (vm._isMounted) {\\n                  callHook(vm, 'beforeUpdate')\\n                }\\n              }\\n            」\\n          */\\n          this.before = options.before\\n        } else {\\n          this.deep = this.user = this.lazy = this.sync = false\\n        }\\n        this.cb = cb\\n        this.id = ++uid // uid for batching\\n        this.active = true\\n        this.dirty = this.lazy // for lazy watchers\\n        // 两个数组，\\n        this.deps = []\\n        this.newDeps = []\\n        // 两个id 为 set 实例,在 add 时候，防止重复添加相同 id\\n        this.depIds = new Set()\\n        this.newDepIds = new Set()\\n        this.expression = process.env.NODE_ENV !== 'production'\\n          ? expOrFn.toString()\\n          : ''\\n        // parse expression for getter\\n        if (typeof expOrFn === 'function') {\\n          this.getter = expOrFn\\n        } else {\\n          this.getter = parsePath(expOrFn)\\n          if (!this.getter) {\\n            this.getter = noop\\n            process.env.NODE_ENV !== 'production' && warn(\\n              `Failed watching path: \\\"${expOrFn}\\\" ` +\\n              'Watcher only accepts simple dot-delimited paths. ' +\\n              'For full control, use a function instead.',\\n              vm\\n            )\\n          }\\n        }\\n        this.value = this.lazy\\n          ? undefined\\n          : this.get()\\n      }\\n\\n      /**\\n       * Evaluate the getter, and re-collect dependencies.\\n       */\\n      // 执行 getter, 并重新收集依赖关系\\n      get () {\\n        /* pushTarget 代码：\\n        「\\n            Dep.target = null\\n            const targetStack = []\\n\\n            export function pushTarget (_target: ?Watcher) {\\n              if (Dep.target) targetStack.push(Dep.target)\\n              Dep.target = _target\\n            }\\n\\n            export function popTarget () {\\n              Dep.target = targetStack.pop()\\n            }\\n          」\\n        */\\n        // 这行代码作用：在进行 get 取值时，使得 Dep.target 为 watcher 实例自身\\n        pushTarget(this)\\n        let value\\n        const vm = this.vm\\n        try {\\n          value = this.getter.call(vm, vm)\\n        } catch (e) {\\n          if (this.user) {\\n            handleError(e, vm, `getter for watcher \\\"${this.expression}\\\"`)\\n          } else {\\n            throw e\\n          }\\n        } finally {\\n          // \\\"touch\\\" every property so they are all tracked as\\n          // dependencies for deep watching\\n          if (this.deep) {\\n            traverse(value)\\n          }\\n          popTarget()\\n          this.cleanupDeps()\\n        }\\n        return value\\n      }\\n\\n      /**\\n       * Add a dependency to this directive.\\n       */\\n      addDep (dep: Dep) {\\n        const id = dep.id\\n        // if (!this.newDepIds.has(id)) 判断，为了防止如 computed 里\\n        // `return this.a + this.a` 这种相同值的计算情况\\n        if (!this.newDepIds.has(id)) {\\n          this.newDepIds.add(id)\\n          this.newDeps.push(dep)\\n          if (!this.depIds.has(id)) {\\n            dep.addSub(this)\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Clean up for dependency collection.\\n       */\\n      cleanupDeps () {\\n        let i = this.deps.length\\n        while (i--) {\\n          const dep = this.deps[i]\\n          if (!this.newDepIds.has(dep.id)) {\\n            dep.removeSub(this)\\n          }\\n        }\\n        let tmp = this.depIds\\n        this.depIds = this.newDepIds\\n        this.newDepIds = tmp\\n        this.newDepIds.clear()\\n        tmp = this.deps\\n        this.deps = this.newDeps\\n        this.newDeps = tmp\\n        this.newDeps.length = 0\\n      }\\n\\n      /**\\n       * Subscriber interface.\\n       * Will be called when a dependency changes.\\n       */\\n      update () {\\n        /* istanbul ignore else */\\n        if (this.lazy) {\\n          this.dirty = true\\n        } else if (this.sync) {\\n          this.run()\\n        } else {\\n          queueWatcher(this)\\n        }\\n      }\\n\\n      /**\\n       * Scheduler job interface.\\n       * Will be called by the scheduler.\\n       */\\n      run () {\\n        if (this.active) {\\n          const value = this.get()\\n          if (\\n            value !== this.value ||\\n            // Deep watchers and watchers on Object/Arrays should fire even\\n            // when the value is the same, because the value may\\n            // have mutated.\\n            isObject(value) ||\\n            this.deep\\n          ) {\\n            // set new value\\n            const oldValue = this.value\\n            this.value = value\\n            if (this.user) {\\n              try {\\n                this.cb.call(this.vm, value, oldValue)\\n              } catch (e) {\\n                handleError(e, this.vm, `callback for watcher \\\"${this.expression}\\\"`)\\n              }\\n            } else {\\n              this.cb.call(this.vm, value, oldValue)\\n            }\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Evaluate the value of the watcher.\\n       * This only gets called for lazy watchers.\\n       */\\n      evaluate () {\\n        this.value = this.get()\\n        this.dirty = false\\n      }\\n\\n      /**\\n       * Depend on all deps collected by this watcher.\\n       */\\n      depend () {\\n        let i = this.deps.length\\n        while (i--) {\\n          this.deps[i].depend()\\n        }\\n      }\\n\\n      /**\\n       * Remove self from all dependencies' subscriber list.\\n       */\\n      teardown () {\\n        if (this.active) {\\n          // remove self from vm's watcher list\\n          // this is a somewhat expensive operation so we skip it\\n          // if the vm is being destroyed.\\n          if (!this.vm._isBeingDestroyed) {\\n            remove(this.vm._watchers, this)\\n          }\\n          let i = this.deps.length\\n          while (i--) {\\n            this.deps[i].removeSub(this)\\n          }\\n          this.active = false\\n        }\\n      }\\n    }\\n  ```\\n</details>\\n\\n上面说到在 set 某个值的时候，实际上会执行 `watcher.update()` 方法。来看下这个 update 方法：\\n```js\\nupdate () {\\n  /* istanbul ignore else */\\n  if (this.lazy) {\\n    this.dirty = true\\n  } else if (this.sync) {\\n    this.run()\\n  } else {\\n    queueWatcher(this)\\n  }\\n}\\n```\\nupdate 方法，同步情况执行 `this.run()` ，一般情况是异步，会进入到最后个 else 里，执行 `queueWatcher(this)`。\\n\\n`queueWatcher` 里主要代码 `nextTick(flushSchedulerQueue)`，它将 watch 队列放到 nextTick 里统一执行，这也使得连续 set 同个数据两次不同值，不会更新两次视图，提升了一定性能。\\n\\n### computed 的原理\\n注意 watcher 实例化 constructor 最后行有个 `this.value`:\\n```js\\nthis.value = this.lazy\\n  ? undefined\\n  : this.get()\\n```\\n这个 value，在 `initComputed` 的时候，会对 computed 里的每个 key `new Watcher(...)`，所以可以说是 computed 的双向绑定实现即是通过 Watcher 来响应变化。\\n\\n<details>\\n  <summary>initComputed 源码函数：</summary>\\n\\n  ```js\\n  const computedWatcherOptions = { lazy: true }\\n\\n  function initComputed (vm: Component, computed: Object) {\\n    // $flow-disable-line\\n    const watchers = vm._computedWatchers = Object.create(null)\\n    // computed properties are just getters during SSR\\n    const isSSR = isServerRendering()\\n\\n    // 遍历定义在 computed 上的 key\\n    for (const key in computed) {\\n      const userDef = computed[key]\\n      // 处理自定义 getter 情况\\n      const getter = typeof userDef === 'function' ? userDef : userDef.get\\n      if (process.env.NODE_ENV !== 'production' && getter == null) {\\n        warn(\\n          `Getter is missing for computed property \\\"${key}\\\".`,\\n          vm\\n        )\\n      }\\n      // 非 ssr 情况，对 key 进行 监控，ssr 下就不需要监控了\\n      if (!isSSR) {\\n        // create internal watcher for the computed property.\\n        // 对每个key 设置 Watcher\\n        watchers[key] = new Watcher(\\n          vm,\\n          getter || noop,\\n          noop,\\n          computedWatcherOptions\\n        )\\n      }\\n      // component-defined computed properties are already defined on the\\n      // component prototype. We only need to define computed properties defined\\n      // at instantiation here.\\n      if (!(key in vm)) {\\n        // 将 computed 里定义的 key 在实例上添加进行代理，使得可直接通过 this.xx 来访问\\n        defineComputed(vm, key, userDef)\\n      } else if (process.env.NODE_ENV !== 'production') {\\n        if (key in vm.$data) {\\n          warn(`The computed property \\\"${key}\\\" is already defined in data.`, vm)\\n        } else if (vm.$options.props && key in vm.$options.props) {\\n          warn(`The computed property \\\"${key}\\\" is already defined as a prop.`, vm)\\n        }\\n      }\\n    }\\n  }\\n  ```\\n</details>\\n\\n从上面传入参数 `{ lazy: true }` 可知，初始化时 value 为 `undefined`，\\n`defineComputed(vm, key, userDef)` 即 `Object.defineProperty(target, key, sharedPropertyDefinition)`.\\n在 `sharedPropertyDefinition` 里会拿之前 watcher 过的依赖的值：\\n```js\\nfunction createComputedGetter (key) {\\n  return function computedGetter () {\\n    const watcher = this._computedWatchers && this._computedWatchers[key]\\n    if (watcher) {\\n      if (watcher.dirty) {\\n        watcher.evaluate()\\n      }\\n      if (Dep.target) {\\n        watcher.depend()\\n      }\\n      return watcher.value\\n    }\\n  }\\n}\\n```\\n所以 computed 中的值在读取的时候，拿到的结果即 watcher.value。\\n\\n**总结下 data 响应式流程：**\\n\\nthis.xx 代理到 this._data.xx 然后 _data 在 Observer 里定义过 setter getter，在初始 render 时会收集依赖到闭包的 Dep 依赖实例的数组里，在 setter 时会通知所有依赖即每个 watcher 实例进行 update 更新。\\n\\n**总结下 computed 响应式流程：**\\n\\nthis.xx 初始化时会先创建一个 watcher，然后通过 `Object.defineProperty` 进行 setter,getter 设置，其中 getter 会得到是 watcher.value 的值。\\n\\n\\n**注意：**\\n> Observer 文件下定义了个 `arrayMethods`，该方法重写了数组方法，使得改变 push 等操作也能触发更新。\\n```js\\nmethodsToPatch.forEach(function (method) {\\n  // cache original method\\n  const original = arrayProto[method]\\n  def(arrayMethods, method, function mutator (...args) {\\n    const result = original.apply(this, args)\\n    const ob = this.__ob__\\n    let inserted\\n    switch (method) {\\n      case 'push':\\n      case 'unshift':\\n        inserted = args\\n        break\\n      case 'splice':\\n        inserted = args.slice(2)\\n        break\\n    }\\n    if (inserted) ob.observeArray(inserted)\\n    // notify change\\n    ob.dep.notify()\\n    return result\\n  })\\n})\\n```\\n\\n附：\\n[实现vue精简版响应式代码](https://github.com/tanxchen/knowledge-note/blob/master/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vuejs/mvvm.html#L1-L137)\",\"__v\":0},{\"_id\":\"5cdd790c9ae55c41e3feed97\",\"meta\":{\"createDate\":\"2019-05-16 22:51:56\",\"updateDate\":\"2019-05-16 22:51:56\"},\"tags\":[\"vue\"],\"title\":\"vue源码阅读之初始化过程\",\"content\":\"### import阶段\\n从打包入口文件入手，`scripts/config.js`, ➡️ `resolve('web/entry-runtime.js')`\\n⤵️\\n入口文件 `src/platforms/entry-runtime.js`, `platforms` 文件夹是跟平台相关的代码\\n⤵️\\n`src/platforms/web/runtime/index.js`，`runtime/index.js` 里对该运行时代码做了特殊处理\\n⤵️\\n`src/code/index.js`,真正入口文件\\n```js\\nimport Vue from './instance/index'\\n// ...\\ninitGlobalAPI(Vue)\\n// ...ssr相关代码\\nVue.version = '__VERSION__'\\n\\nexport default Vue\\n```\\n⤵️\\n`src/core/instance/index.js`\\n```js\\nfunction Vue (options) {\\n  // ...\\n  this._init(options)\\n}\\n// 添加 _init 函数\\ninitMixin(Vue)\\n// 主要是添加了 $data,$props,$watch,$set,$delete 几个属性和方法\\nstateMixin(Vue)\\n// 主要是添加了 $on,$off,$once,$emit 三个方法\\neventsMixin(Vue)\\n// 主要添加了 _update, $forceUpdate, $destroy 三个方法\\nlifecycleMixin(Vue)\\n// 主要添加了 $nextTick 和 _render 两个方法以及一大堆renderHelpers\\nrenderMixin(Vue)\\n\\nexport default Vue\\n```\\n`instance/index.js` 作用是按功能模块往 `Vue` 原型和自身添加了许多属性和方法。\\n再回到 `initGlobalAPI(Vue)`.\\n```js\\n// 一般使用的是实例里的方法\\nVue.set = set\\nVue.delete = del\\nVue.nextTick = nextTick\\n\\nVue.options = Object.create(null)\\n// 循环出来的结果其实是三个 `components`,`directives`, `filters`\\nASSET_TYPES.forEach(type => {\\n  Vue.options[type + 's'] = Object.create(null)\\n})\\n\\n// this is used to identify the \\\"base\\\" constructor to extend all plain-object\\n// components with in Weex's multi-instance scenarios.\\nVue.options._base = Vue\\n\\n// builtInComponents 仅为内置组件 KeepAlive\\nextend(Vue.options.components, builtInComponents)\\n\\ninitUse(Vue) // 添加 Vue.use\\ninitMixin(Vue) // 添加 Vue.mixin\\ninitExtend(Vue) // 添加 Vue.extend\\n// 添加 Vue.component, Vue.directive, Vue.filter 方法\\ninitAssetRegisters(Vue)\\n```\\n`initGlobalAPI` 作用也是继续添加了一些全局方法。\\n现在 function Vue 大致就变成了如下样子：\\n```js\\n//构造函数\\nfunction Vue () {\\n  this._init()\\n}\\n\\n//全局config对象，我们几乎不会用到\\nVue.config = {\\n  keyCodes,\\n  _lifecycleHooks: ['beforeCreate', 'created', ...]\\n}\\n\\n// 默认的options配置，我们每个组件都会继承这个配置。\\nVue.options = {\\n  beforeCreate, // 比如 vue-router 就会注册这个回调，因此会每一个组件继承\\n  components, // 前面提到了，默认组件有三个 `KeepAlive`,`transition`, `transitionGroup`，这里注册的组件就是全局组件，因为任何一个组件中不用声明就能用了。所以全局组件的原理就是这么简单\\n  directives, // 默认只有 `v-show` 和 `v-model`\\n  filters\\n}\\n\\n//一些全局方法\\nVue.use // 注册插件\\nVue.component // 注册组件\\nVue.directive // 注册指令\\nVue.nextTick //下一个tick执行函数\\nVue.set/delete // 数据的修改操作\\nVue.mixin // 混入mixin用的\\n\\n//Vue.prototype 上有几种不同作用的方法\\n\\n//由initMixin 添加的 `_init` 方法，是Vue实例初始化的入口方法，会调用其他的功能初始话函数\\nVue.prototype._init\\n\\n// 由 initState 添加的三个用来进行数据操作的方法\\nVue.prototype.$data\\nVue.prototype.$props\\nVue.prototype.$watch\\nVue.prototype.$set\\nVue.prototype.$delete\\n\\n// 由initEvents添加的事件方法\\nVue.prototype.$on\\nVue.prototype.$off\\nVue.prototype.$one\\nVue.prototype.$emit\\n\\n// 由 lifecycle添加的生命周期相关的方法\\nVue.prototype._update\\nVue.prototype.$forceUpdate\\nVue.prototype.$destroy\\n\\n//在 platform 中添加的生命周期方法\\nVue.prototype.$mount\\n\\n// 由renderMixin添加的`$nextTick` 和 `_render` 以及一堆renderHelper\\nVue.prototype.$nextTick\\nVue.prototype._render\\nVue.prototype._b\\nVue.prototype._e\\n//...\\n```\\n\\n### 实例化阶段[new Vue({...})]\\n代码在 `src/core/instance/init.js` 里。\\n主要功能代码：\\n* 生成自增的唯一ID标识 `vm._uid = uid++`\\n* 合并 `vm.constructor` 和传入的 `options`，生成 `vm.$options`\\n  * 这一步使得可以在子组件能够使用全局的 directives、filters 等方法\\n* 挂载自身 `vm._self = vm`\\n* 初始化生命周期、事件、渲染等相关钩子工作\\n  * initLifecycle(vm)\\n    * 定位第一个非抽象父级，并添加到 $children 里，`parent.$children.push(vm)`\\n    * 添加很多变量，主要为 $parent、$children，$refs 也在这里定义了，其他 `_`开头的变量均为\\b生命周期不同阶段状态的 flag\\n      * vm.$parent = parent\\n      * vm.$root = parent ? parent.$root : vm\\n      * vm.$children = []\\n      * vm.$refs = {}\\n      * vm._watcher = null\\n      * vm._inactive = null\\n      * vm._directInactive = false\\n      * vm._isMounted = false\\n      * vm._isDestroyed = false\\n      * vm._isBeingDestroyed = false\\n  * initEvents(vm)\\n    * > **注册的是父组件事件**\\n  * initRender(vm)\\n    * 做 render 的准备工作，并未开始 render，如创建 vm._vnode，vm.$createElement，$attrs 和 $listeners\\n  * callHook(vm, 'beforeCreate')\\n    * 调用 `beforeCreate` 生命周期钩子\\n    * > callHook 里定义了：`if (vm._hasHookEvent) {vm.$emit('hook:' + hook)}`，所以有个小技巧实现在在父组件通过 `hook` 钩子，监听子组件生命周期方法:\\n    * \\n      ```html \\n        <Chind-Component @hook:updated=\\\"doSomething\\\" /> \\n      ```\\n  * initInjections(vm) // resolve injections before data/props\\n  * initState(vm)\\n    * `data`, `props`, `computed` 等都是在这里初始化的，常见的面试考点比如`Vue是如何实现数据响应化的` 答案就在这个函数中寻找\\n  * initProvide(vm) // resolve provide after data/props\\n  * callHook(vm, 'created')\\n    * 调用 `created` 生命周期钩子\\n* 存在 el ,则调用 `$mount`，`vm.$mount(vm.$options.el)`\\n  * 当然，el 也可以不写，而是在实例化的时候直接调用： `new Vue({...}).$mount('#app')`\",\"__v\":0},{\"_id\":\"5cda85489ae55c41e3feed96\",\"meta\":{\"createDate\":\"2019-05-14 17:07:20\",\"updateDate\":\"2019-05-14 17:23:12\"},\"tags\":[\"nodejs\"],\"title\":\"koa中间件原理\",\"content\":\"koa 功能\\n* 封装 http 模块【lib/application 下的 listen 方法】\\n* 构建中间件模型【通过 koa-compose 包】\\n* 整合了request,response,context【lib/application 下的 createContext 方法】\\n* 错误处理【lib/application 下的 onerror 方法】\\n\\n一个基础模板代码如下：\\n```js\\nconst Koa = require('koa');\\nconst app = new Koa();\\n\\n// logger\\napp.use(async (ctx, next) => {\\n  await next();\\n  const rt = ctx.response.get('X-Response-Time');\\n  console.log(`${ctx.method} ${ctx.url} - ${rt}`);\\n});\\n\\n// x-response-time\\napp.use(async (ctx, next) => {\\n  const start = Date.now();\\n  await next();\\n  const ms = Date.now() - start;\\n  ctx.set('X-Response-Time', `${ms}ms`);\\n});\\n\\n// response\\napp.use(async ctx => {\\n  ctx.body = 'Hello World';\\n});\\n\\napp.listen(3000);\\n```\\n\\nkoa 里，中间件函数接收两个参数 context, next，\\n通过 use 方法，将函数添加到 `middleware` 数组里【 `this.middleware.push(fn)` 】，\\n在 listen 里\\n```js\\nhttp.createServer(this.callback()).listen(...args);\\n```\\n调用了 `callback`，在 `callback` 里，通过 `compose(this.middleware)`，\\n处理之前添加过的中间件，返回 `this.handleRequest(ctx, fn)` 来执行中间件，\\n`handleRequest` 是返回 Promise 函数的，所以在编写中间件时，往往通过 async await 来构建，这里主要来解析下 `compose`，它是引用了 `koa-compose` 包，主要源码如下：\\n```js\\nfunction compose () {\\n  return function (context, next) {\\n    // last called middleware\\n    let index = -1\\n    return dispatch(0)\\n    function dispatch (i) {\\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\\n      index = i\\n      let fn = middleware[i]\\n      if (i === middleware.length) fn = next\\n      if (!fn) return Promise.resolve()\\n      try {\\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\\n      } catch (err) {\\n        return Promise.reject(err)\\n      }\\n    }\\n  }\\n}\\n```\\n\\ncompose 里会返回 dispatch 方法，dispatch 里会先执行第一个fn，并将 middleware 队列里下一个 fn 作为 next 参数，且 dispatch 返回的为 Promise，从而形成了先进后出洋葱式模型。\\n![koa-middleware](https://gitee.com/tanxchen/img/raw/master/blog/koa-middleware.jpg)\",\"__v\":0},{\"_id\":\"5ccff6409ae55c41e3feed95\",\"meta\":{\"createDate\":\"2019-05-06 16:54:24\",\"updateDate\":\"2019-05-06 16:54:24\"},\"tags\":[\"vue\"],\"title\":\"Vuex源码分析\",\"content\":\"Vuex是Vue的数据状态管理插件.将数据放在单例下的store里，对数据进行监控管理.\\n### 引入、安装阶段，从入口 index.js开始\\n```js\\nexport default {\\n  Store,\\n  install,\\n  version: '__VERSION__',\\n  mapState,\\n  mapMutations,\\n  mapGetters,\\n  mapActions,\\n  createNamespacedHelpers\\n}\\n```\\n导出了 Store 类和一些辅助map开头的函数。\\n最初在项目里使用Vuex时，`Vue.use(Vuex)`里便是调用了`install`方法。\\n```js\\n// ...\\nlet Vue\\n// ...\\n// 初始install阶段，Vue.use(Vuex)会调用install方法\\nexport function install (_Vue) {\\n  // Vue为store里定义，_Vue为调用install时传入的Vue\\n  // 防止重复install\\n  if (Vue && _Vue === Vue) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      console.error(\\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\\n      )\\n    }\\n    return\\n  }\\n  Vue = _Vue\\n  // applyMixin函数作用：将store注入到子组件，子组件可通过this.$store访问store\\n  applyMixin(Vue)\\n}\\n```\\nstore.js里导出了`install`方法。在store.js开头定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。\\n这里调用`applyMixin`方法，它将store注入到子组件，子组件可通过this.$store访问store\\n`// applyMixin.js`\\n```js\\nif (version >= 2) {\\n  Vue.mixin({ beforeCreate: vuexInit })\\n} \\n```\\napplyMixin里对 vue 1.0 和 2.0 版本进行了判断，2.0下在`beforeCreate`阶段注入`store`\\n```js\\n// 子组件可以通过this.$store来访问store\\nfunction vuexInit () {\\n  const options = this.$options\\n  // 注入store\\n  // 初始时，在根组件上，调用者会传入store，所以会进入if逻辑\\n  if (options.store) {\\n    // options上的store可以为 function，\\n    // 这类似于 vue 里的 data return 的是个 function，防止多个 store下，里面的数据被共享\\n    this.$store = typeof options.store === 'function'\\n      ? options.store()\\n      : options.store\\n  } else if (options.parent && options.parent.$store) {\\n    // 在子组件上，初始化时未传入store，则从父组件中获取store\\n    // 公用了一份初始根组件时传入的全局的store\\n    this.$store = options.parent.$store\\n  }\\n}\\n```\\n### new Store实例化阶段\\n```js\\n  // plugins为外部传入的插件\\n  // strict为默认不开启严格模式（严格模式：只能在mutation里进行数据更改，在action等其他位置进行数据更改会抛出错误）\\n  const {\\n    plugins = [],\\n    strict = false\\n  } = options\\n\\n  // 定义store 内部状态\\n  // 用于判断是否在commit环节的flag，保证只在mutation环境改变state\\n  this._committing = false\\n  // actions操作对象\\n  this._actions = Object.create(null)\\n  // 发布订阅模式下的订阅函数集合\\n  this._actionSubscribers = []\\n  // mutations操作对象\\n  this._mutations = Object.create(null)\\n  // 封装后的getters集合对象\\n  this._wrappedGetters = Object.create(null)\\n  /**\\n   * 格式化 options，也是该源码阅读的核心重点，\\n   * 在非模块模式（普通用法传入options）或 在按模块开发方式传入store时，存储处理过的modules\\n   * this._modules = {\\n   *   root: {\\n   *     context: {dispatch: ƒ, commit: ƒ},\\n   *     runtime: false,\\n   *     state: {…},\\n   *     _children: {},\\n   *     _rawModule: {state: {…}, actions: {…}, mutations: {…}, plugins: Array(1)},\\n   *     namespaced: false\\n   *   },\\n   *   __proto__: {\\n   *    get: ƒ (path)\\n   *    getNamespace: ƒ getNamespace(path)\\n   *    register: ƒ register(path, rawModule, runtime)\\n   *    unregister: ƒ unregister(path)\\n   *    update: ƒ update$1(rawRootModule)\\n   *    constructor: ƒ ModuleCollection(rawRootModule)\\n   *    __proto__: {...}\\n   *   }\\n   * }\\n   */\\n  this._modules = new ModuleCollection(options)\\n  // 模块命名空间map\\n  this._modulesNamespaceMap = Object.create(null)\\n  // 发布订阅模式下的订阅函数集合\\n  this._subscribers = []\\n  // vue实例，用到watch监视变化功能\\n  this._watcherVM = new Vue()\\n  // ...\\n  installModule(this, state, [], this._modules.root)\\n\\n  // initialize the store vm, which is responsible for the reactivity\\n  // (also registers _wrappedGetters as computed properties)\\n  resetStoreVM(this, state)\\n\\n  // 调用传入的各种插件\\n  plugins.forEach(plugin => plugin(this))\\n\\n  const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools\\n  if (useDevtools) {\\n    devtoolPlugin(this)\\n  }\\n```\\n在 `constructor` 里主要操作为： 格式化modules，安装 module，初始化 store vm, 安装 plugins\\n\\n### 格式化modules，即 `this._modules = new ModuleCollection(options)`\\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\\n\\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。\\n每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\\n```js\\nconst moduleA = {\\n  state: { ... },\\n  mutations: { ... },\\n  actions: { ... },\\n  getters: { ... }\\n}\\n\\nconst moduleB = {\\n  state: { ... },\\n  mutations: { ... },\\n  actions: { ... }\\n}\\n\\nconst store = new Vuex.Store({\\n  state: { ... },\\n  modules: {\\n    a: moduleA,\\n    b: moduleB\\n  }\\n})\\n```\\n代码被分割到 `./module/module-collection` 文件夹下。\\n初始化时，执行 `register` 方法\\n```js\\nthis.register([], rawRootModule, false)\\n```\\nregister 接收3个参数\\n  * path：路径，模块tree的路径\\n  * rawModule：最初 `new Store` 时传入的 `options`\\n  * runtime：是否是运行时创建的模块,在初始化根模块时为 false， 其他情况为 true，理解为 初始化时的 flag\\n\\n如初始化 register 时，参数为：`path: [], rawModule: options, runtime: false`\\n```js\\nregister (path, rawModule, runtime = true) {// path: [], rawModule: options, runtime: false\\n  if (process.env.NODE_ENV !== 'production') {\\n    // 对构造器传入的options的getters、mutations、actions进行dev环境的格式校验\\n    // 非预期的格式会抛出错误\\n    assertRawModule(path, rawModule)\\n  }\\n\\n  // 初始化module\\n  const newModule = new Module(rawModule, runtime)\\n  // 第一次初始化时，执行if代码块，path为[]\\n  if (path.length === 0) {\\n    this.root = newModule\\n  } else {\\n    // 获取当前module的parent\\n    const parent = this.get(path.slice(0, -1))\\n    // 添加child\\n    parent.addChild(path[path.length - 1], newModule)\\n  }\\n\\n  // 递归注册嵌套的module\\n  if (rawModule.modules) {\\n    forEachValue(rawModule.modules, (rawChildModule, key) => {\\n      this.register(path.concat(key), rawChildModule, runtime)\\n    })\\n  }\\n}\\n```\\nregister 里的逻辑大致为\\n * 校验传入的options格式，非预期的格式会抛出错误\\n * 实例化 `Module`，初始化时 模块 tree 的根即为 root，之后 addChild 添加的子模块 即会放入到 root._children 里，逐级对包含的所以模块进行递归 register，以形式 模块 tree\\n\\nroot格式如下：\\n```js\\nroot: {\\n  context: {dispatch: ƒ, commit: ƒ},\\n  runtime: false,\\n  state: {…},\\n  _children: {},\\n  _rawModule: {state: {…}, actions: {…}, mutations: {…}, plugins: Array(1)},\\n  namespaced: false\\n}\\n```\\n#### 初始化module\\n```js\\n// 初始化module\\nconst newModule = new Module(rawModule, runtime)\\n```\\nModule 定义在 `./module/module.js` 里\\n\\n构造函数：\\n```js\\nconstructor (rawModule, runtime) {// rawModule: options, runtime: false\\n  this.runtime = runtime\\n  // 存储module子项\\n  this._children = Object.create(null)\\n  // 存储初始化时传入的原始options\\n  this._rawModule = rawModule\\n  const rawState = rawModule.state\\n\\n  // 兼容module形式里state传入函数形式，类似 组件中的 data，总是return 一个Object，来防止对象被共享\\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {}\\n}\\n```\\n屡下 模块初始化 思路：\\n  * 对初始传入的 options 进行模块 实例化，\\n  * 里面包含了子模块的话 会被递归 放进 root._children 对象里，形成一颗 模块 tree，\\n  * 并且 通过 `forEachMutation` 包装函数等的类似方法，子模块在执行 action、mutation 方法时也只是执行的是子模块里对应的方法，\\n  * 每个模块的 _rawModule 即为 定义时 传入的 options\\n  * 每个模块的 state 即为 定义时 传入的 options.state\\n\\n### 安装模块\\n```js\\ninstallModule(this, state, [], this._modules.root)\\n```\\n在模块被初始化定义后，通过 installModule 对 state, actions, mutations, getters 进行初始化处理。\\n\\n```js\\nfunction installModule (store, rootState, path, module, hot) {\\n  // this, state(this._modules.root.state), [], this._modules.root\\n  // 是root时，path为[]\\n  const isRoot = !path.length\\n  //  modules: {\\n  //     a: moduleA,\\n  //     b: moduleB\\n  //   }\\n  // modules.a 的命名空间为 'a/'\\n  const namespace = store._modules.getNamespace(path)\\n\\n  // 存储namespace对应的module于_modulesNamespaceMap\\n  if (module.namespaced) {\\n    store._modulesNamespaceMap[namespace] = module\\n  }\\n\\n  // 设置 state\\n  if (!isRoot && !hot) {\\n    const parentState = getNestedState(rootState, path.slice(0, -1))\\n    const moduleName = path[path.length - 1]\\n    store._withCommit(() => {\\n      Vue.set(parentState, moduleName, module.state)\\n    })\\n  }\\n\\n  const local = module.context = makeLocalContext(store, namespace, path)\\n\\n  // 拼接namespace，如：\\n  // modules: {\\n  //   account: {\\n  //     namespaced: true,\\n  //     state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\\n  //     getters: {\\n  //       isAdmin () { ... } // -> getters['account/isAdmin']\\n  //     },\\n  //     actions: {\\n  //       login () { ... } // -> dispatch('account/login')\\n  //     },\\n  //     mutations: {\\n  //       login () { ... } // -> commit('account/login')\\n  //     }\\n  //   }\\n  // }\\n  module.forEachMutation((mutation, key) => {\\n    const namespacedType = namespace + key\\n    registerMutation(store, namespacedType, mutation, local)\\n  })\\n\\n  module.forEachAction((action, key) => {\\n    const type = action.root ? key : namespace + key\\n    const handler = action.handler || action\\n    registerAction(store, type, handler, local)\\n  })\\n\\n  module.forEachGetter((getter, key) => {\\n    const namespacedType = namespace + key\\n    registerGetter(store, namespacedType, getter, local)\\n  })\\n\\n  // 递归install子项\\n  module.forEachChild((child, key) => {\\n    installModule(store, rootState, path.concat(key), child, hot)\\n  })\\n}\\n```\\n#### 分析下 registerMutation 的注册\\n在这里先通过 forEachMutation 方法, 传入对应的模块的 mutation 和 key，\\nregisterMutation 里将我们项目里定义的 mutations 方法以 key-value 形式存入 _mutations 里，在传入的时候 将 state 作为第一参数，我们自己传入的为第二参数形式，这里使得如文档里所说一样形式使用：\\n```js\\n// ...\\nmutations: {\\n  increment (state, payload) {\\n    state.count += payload.amount\\n  }\\n}\\n```\\n> 这里会对命名空间进行处理，假如模块 A 中有名为 add 的 mutation 函数，那么在注册过程中会变成 a/add\\n\\n相关 Mutation 注册代码：\\n->>>>>>>>>>>>\\n```js\\nmodule.forEachMutation((mutation, key) => {\\n  const namespacedType = namespace + key\\n  registerMutation(store, namespacedType, mutation, local)\\n})\\n//\\nforEachMutation (fn) {\\n  if (this._rawModule.mutations) {\\n    forEachValue(this._rawModule.mutations, fn)\\n  }\\n}\\n//\\nfunction registerMutation (store, type, handler, local) {\\n  const entry = store._mutations[type] || (store._mutations[type] = [])\\n  entry.push(function wrappedMutationHandler (payload) {\\n    handler.call(store, local.state, payload)\\n  })\\n}\\n```\\n<<<<<<<<<<\\n\\n#### registerAction 的注册\\n```js\\nfunction registerAction (store, type, handler, local) {\\n  const entry = store._actions[type] || (store._actions[type] = [])\\n  entry.push(function wrappedActionHandler (payload, cb) {\\n    let res = handler.call(store, {\\n      dispatch: local.dispatch,\\n      commit: local.commit,\\n      getters: local.getters,\\n      state: local.state,\\n      rootGetters: store.getters,\\n      rootState: store.state\\n    }, payload, cb)\\n    if (!isPromise(res)) {\\n      res = Promise.resolve(res)\\n    }\\n    if (store._devtoolHook) {\\n      return res.catch(err => {\\n        store._devtoolHook.emit('vuex:error', err)\\n        throw err\\n      })\\n    } else {\\n      return res\\n    }\\n  })\\n}\\n```\\n这里将 `{ dispatch commit getters state rootGetters rootState }` 作为第一参数，将自己dispatch 时传入的参数作为第二参数，所以有了文档里所说的书写形式：\\n```js\\n// 自己项目里的 actions.js\\ntoggleMenu ({ commit }) {\\n  commit('TOGGLE_MENU')\\n},\\n// or\\nsetSidebarMenuList (context, userType) {\\n  context.commit('SET_SIDEBAR_MENU_LIST', userType)\\n}\\n```\\n> registerAction 里 处理了 promise 情况，所以 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise\\n\\n所以我们可以这么来写：\\n```js\\nlogin({commit}, user){\\n  return new Promise((resolve, reject) => {\\n    commit('auth_request')\\n    axios({url: '...', data: user, method: 'POST' })\\n      .then(resp => {\\n        const token = resp.data.token\\n        const user = resp.data.user\\n        localStorage.setItem('token', token)\\n        axios.defaults.headers.common['Authorization'] = token\\n        commit('auth_success', token, user)\\n        resolve(resp)\\n      })\\n      .catch(err => {\\n        commit('auth_error')\\n        localStorage.removeItem('token')\\n        reject(err)\\n      })\\n  })\\n}\\n```\\n```js\\nexport default {\\n  methods: {\\n    register () {\\n      this.$store.dispatch('register', {\\n        name: this.name,\\n        password: this.password\\n      })\\n        .then(() => this.$router.push('/'))\\n        .catch(err => console.log(err))\\n    }\\n  }\\n}\\n```\\n将处理的请求提取到了vuex里，也使得页面里代码更加简洁了。只保留了业务逻辑。\\n\\n#### registerGetter 的注册\\n```js\\n// ...\\nreturn rawGetter(\\n  local.state, // local state\\n  local.getters, // local getters\\n  store.state, // root state\\n  store.getters // root getters\\n)\\n```\\ngetter 这里先处理了命名空间，然后这里接收 4 个参数。\\n前面两个为模块内的 local state ，local getters，后两个参数为根节点上的内容 root state，root getters。\\n当然，没使用模块形式的话，两者相同。\\n\\n### resetStoreVM(this, state)\\n```js\\nfunction resetStoreVM (store, state, hot) {\\n  const oldVm = store._vm\\n\\n  // bind store public getters\\n  store.getters = {}\\n  const wrappedGetters = store._wrappedGetters\\n  const computed = {}\\n  forEachValue(wrappedGetters, (fn, key) => {\\n    // use computed to leverage its lazy-caching mechanism\\n    computed[key] = () => fn(store)\\n    Object.defineProperty(store.getters, key, {\\n      get: () => store._vm[key],\\n      enumerable: true // for local getters\\n    })\\n  })\\n\\n  // ...\\n  store._vm = new Vue({\\n    data: {\\n      $$state: state\\n    },\\n    computed\\n  })\\n  // ...\\n}\\n```\\nresetStoreVM 的工作是 实例化一个 vue 实例，并将 getters 里定义的方法 通过 Object.defineProperty 来进行绑定到 store.getters 上，\\n并作为 computed 计算属性，在state变化时，getter 能响应式变化。\\n在实际调用 即为如下关系：\\n```js\\n// 这里使得vm.$store.state 取到 vm._data.$$state\\nget state () {\\n  return this._vm._data.$$state\\n}\\n```\\n```js\\nstore.state = store._vm._data.$$state\\nstore.getters.a = store.a = store._vm._data.$$state.a\\n```\\nVuex 还有一些map开头的辅助函数，这些 handler 通过 hook 达到了简写的目的。\\nVuex 本身是 Vue 的插件形式，其自身继续延续支持插件形式。`replaceState`,`subscribe`通常会在插件里用到。\\n```js\\nstore.subscribe((mutation, state) => {\\n  console.log(mutation.type)\\n  console.log(mutation.payload)\\n})\\n```\",\"__v\":0},{\"_id\":\"5c4b2ef6425f444b816c7a18\",\"meta\":{\"createDate\":\"2019-01-25 23:44:55\",\"updateDate\":\"2019-05-05 17:43:35\"},\"tags\":[\"笔记\"],\"title\":\"浏览器相关知识点\",\"content\":\"### 浏览器输入url到看到页面\\b的流程\\n* DNS解析\\n  - DNS服务器对域名解析，得到目标服务器的IP后，进行HTTP访问\\n* ↓\\n* 应用层【HTTP数据】\\n* ↓\\n* 传输层【TCP协议：确保可靠性】\\n  - 为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\\n  - 三次握手🤝\\n    - 握手过程中使用了TCP的标志 [flag] —— SYN [synchronize] 和 ACK [acknowledgement]\\n        - \\b发送端首先发送一个带 SYN 标志的数据包给对方。\\n        - 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。\\n        - 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。<br><img src=\\\"https://gitee.com/tanxchen/img/raw/master/blog/tcp-3-call.jpg\\\" width=\\\"420px\\\" height=\\\"280px\\\">\\n  - 除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性\\n* ↓\\n* 网络层【IP协议：负责传输、ARP协议：地址解析协议】\\n  - 增加作为通信目的地的 MAC 地址\\n  - ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址\\n* ↓\\n* 数据链路层\\n* ↓\\n* 服务器\\n  - 数据链路层接收，\\b\\b按序往上层发送，并把对应的首部消去，TCP按序重组请求报文，HTTP处理请求，返回响应\\n* ↓\\n* 处理请求，返回响应内容\\n* ↓\\n* 浏览器得到资源内容/报文，进行解析渲染\\n  * 检查HTML并构建DOM\\n    - 字节 -> 字符串 -> node -> DOM\\n  * 检查CSS并构建CSSOM【CSS Object Model，是一个建立在web页面上的 CSS 样式的映射】\\n    - 字节 -> 字符串 -> node -> DOM\\n  * Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）\\n    - 包含节点\\b和节点样式信息\\n  * 渲染引擎\\b根据 RenderTree 开始渲染和展示\\n    - 布局（回流）：确定节点位置和大小\\n    - 绘制：调用CPU，合成图层，显示与屏幕\\n  * 遇到 script、link 会阻塞\\n* 断开连接，四次挥手👋<br>\\n<img src=\\\"https://gitee.com/tanxchen/img/raw/master/blog/http-tcp.jpg\\\" width=\\\"450px\\\" height=\\\"450px\\\">\\n<br>\\n<hr>\\n<br>\\n<img src=\\\"https://gitee.com/tanxchen/img/raw/master/blog/all.jpg\\\" width=\\\"500px\\\" height=\\\"700px\\\">\\n\\n### 协议对应OSI七层模型位置：\\n* 物理层\\n* 数据链路层\\n* 网络层\\n  - IP\\n* 传输层\\n  - TCP\\n  - UDP(User Data Protocal): 用户数据报协议\\n    - 不可靠，可能丢包而且包的顺序性也不能保证\\n* 会话层\\n* 表示层\\n* 应用层\\n  - http\\n\\n### 重绘、回流有什么区别？\\n* 网页生成时，至少会渲染一次，在用户\\b访问过程中，还会不断重新渲染\\n* 重绘是当节点需要更改外观而不影响布局，如：color的改变\\n* \\b回流是布局或者几何属性的改变，如：width、height的改变\\n* \\b回流必定发生重绘，重绘未必引发回流\\n\\n### async 和 defer 有什么区别？\\n* async 如果已经加载好，就会开始执行\\n* \\bdefer 不阻塞 HTML 的解析，HTML解析完后，再执行\\n* 加载多个JS脚本，async无序加载，而defer有序加载\\n  - 如加载 谷歌统计代码，使用async\\n  - 加载 JS相互依赖代码，使用defer，如 jQuery.js、jQuery-plugin.js\\n\\n### 为什么操作DOM慢？\\n* 相当于不同线程之间的通信\\n* 可能带来重绘、回流\\n\\n### 强缓存和协商缓存\\n> 强缓存是不经过服务器的, 协商缓存是经过服务器的\\n\\n> 强缓存可能从本地内存获取，也可能从本地磁盘内读取\\n\\n* 强缓存相关字段(Expires(响应头), Cache-Control(响应头)),\\n  > Cache-Control优先级大于Expires\\n  - Cache-Control \\n    - no-cache：强制向源服务器再次验证\\n    - no-store：不缓存请求或响应的任何内容，**这才是真的'no-cache'不缓存**\\n    - ...\\n* 协商缓存相关字段(Last-Modified(响应头), If-Modified-Since(请求头), Etag(响应头), If-None-Match(请求头))\\n\\nHTTP 缓存机制流程图:\\n\\n![catch](https://gitee.com/tanxchen/img/raw/master/blog/cache.jpeg)\\n\\n### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？\\n\\n\\n<hr>\\n\\n[参考-图解HTTP](https://book.douban.com/subject/25863515/)<br>\\n[参考-Introduction to the CSS Object Model](https://varvy.com/performance/cssom.html)<br>\\n[参考-掘金文章-深入浅出浏览器渲染原理](https://juejin.im/post/5c24d736f265da614b120d4a)<br>\\n[参考-掘金文章-TCP的三次握手四次挥手](https://juejin.im/post/5a0444d45188255ea95b66bc)<br>\\n[参考-segmentfault文章-从URL输入到页面展现到底发生什么？](https://segmentfault.com/a/1190000017184701)<br>\\n[参考-github.com/MuYunyun/blog](https://github.com/MuYunyun/blog/blob/master/BasicSkill/http/http.md)\\n\\nARP协议相关资料：[ARP协议百度百科](https://baike.baidu.com/item/ARP/609343)\\n\",\"__v\":0},{\"_id\":\"5c4672b79f894d0f47f5f53c\",\"meta\":{\"createDate\":\"2019-01-22 09:32:39\",\"updateDate\":\"2019-01-22 09:32:39\"},\"tags\":[\"javascript\"],\"title\":\"已知年月，求该月共多少天？\",\"content\":\"在写日历组件时，曾遇到 **已知年月，求该月共多少天？** 这样的需求。\\n\\n最开始思路会是：\\n\\n* 先判断该年份是否是闰年，来处理 2 月份情况，闰年 2 月共 29 天，非闰年 2 月共 28 天\\n* 再判断其他月份，如 1 月共 31 天，4 月共 30 天\\n\\n代码就不一一列出了，思路代码啥的没啥问题。\\n\\n这里其实有种更简便的方法，借助 `Date` API 处理日期溢出时，会自动往后推延响应时间的规则，直接上代码：\\n\\n```js\\n// month 值需对应实际月份减一，如实际 2 月，month 为 1，实际 3 月，month 为 2\\nfunction getMonthCountDay (year, month) {\\n  return 32 - new Date(year, month, 32).getDate()\\n}\\n```\\n\\n验证下：\\n\\n```js\\n// 求闰年的 2 月份总天数\\ngetMonthCountDay(2000, 1) // 29\\n// 求非闰年的 2 月份总天数\\ngetMonthCountDay(2001, 1) // 28\\n// 求 1 月份总天数\\ngetMonthCountDay(2000, 0) // 31\\ngetMonthCountDay(2001, 0) // 31\\n// 求 4 月份总天数\\ngetMonthCountDay(2000, 3) // 30\\ngetMonthCountDay(2001, 3) // 30\\n```\",\"__v\":0},{\"_id\":\"5c45d9fe9f894d0f47f5f53b\",\"meta\":{\"createDate\":\"2019-01-21 22:41:02\",\"updateDate\":\"2019-01-21 22:43:24\"},\"tags\":[\"css\"],\"title\":\"CSS里的BFC\",\"content\":\"## BFC概念\\n块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。是CSS2.1规范定义的内容。\\n\\n**下列方式会创建块格式化上下文：**\\n\\n* 根元素或包含根元素的元素\\n* 浮动元素（元素的 `float` 不是 `none`）\\n* 绝对定位元素（元素的 `position` 为 `absolute` 或 `fixed`）\\n* 行内块元素（元素的 `display` 为 `inline-block`）\\n* 表格单元格（元素的 `display`为 `table-cell`，HTML表格单元格默认为该值）\\n* 表格标题（元素的 `display` 为 `table-caption`，HTML表格标题默认为该值）\\n* 匿名表格单元格元素（元素的 `display`为 `table`、`table-row`、 `table-row-group`、t`able-header-group`、`table-footer-group`（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 `inline-table`）\\n* overflow 值不为 `visible` 的块元素\\n* display 值为 `flow-root` 的元素\\n* contain 值为 `layout`、`content`或 `strict` 的元素\\n* 弹性元素（`display`为 `flex` 或 `inline-flex`元素的直接子元素）\\n* 网格元素（`display为` `grid` 或 `inline-grid` 元素的直接子元素）\\n* 多列容器（元素的 `column-count` 或 `column-width` 不为 `auto`，包括 `column-count` 为 1）\\n* `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。\\n\\n*块格式化上下文包含创建它的元素内部的所有内容.*\\n\\n> 根元素即为一个BFC\\n\\n### 特性\\n\\n* 属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关，仅保留较大的margin值\\n* 消除与浮动元素的重叠\\n* 可制造内部浮动（计算BFC的高度时，浮动子元素也参与计算）\\n* 每个元素的margin-left，与包含块border-left相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此（见demo里的part3）。\\n### demo\\n[demo](https://codepen.io/tanxchen/pen/OdLbwq)\\n\\n### 总结\\nBFC是文档内元素显示的一种形式，概念有点抽象,可想像成在文档里为一个密闭的空间，与外部进行了隔离。在默认情况下，根元素即为BFC。所以在根元素内部的元素垂直方向会产生margin重合，浮动元素会产生元素重叠，BFC可消除元素内的子\\b元素浮动产生的不包含情况等特性。\\n\\n[参考MDN链接](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context)\",\"__v\":1},{\"_id\":\"5c376a7c9f894d0f47f5f53a\",\"meta\":{\"createDate\":\"2019-01-10 23:53:32\",\"updateDate\":\"2019-01-15 17:03:36\"},\"tags\":[\"javascript\"],\"title\":\"简单实现浅拷贝与深拷贝\",\"content\":\"### 深浅拷贝区别\\n浅拷贝只复制第一层可枚举的属性值，深拷贝对每一层里的可枚举的属性值都进行复制。\\n\\n* ### 简单实现浅拷贝\\n\\n```js\\nfunction copy (source) {\\n  if (source === null || typeof source !== 'object') return source;\\n  const copy = Array.isArray(source) ? [] : {};\\n\\n  Object.keys(source).forEach(key => {\\n    copy[key] = source[key]\\n  })\\n  return copy\\n}\\n```\\n浅拷贝的实现有\\n  - `Object.assign` \\n  - `...`展开语法\\n  - `Array.prototype.slice()`\\n  - 数组的`concat`\\n \\n  \\n* ### 简单实现深拷贝\\n\\n```js\\nfunction deepCopy (source) {\\n  if (source === null || typeof source !== 'object') return source;\\n  const copy = Array.isArray(source) ? [] : {};\\n\\n  Object.keys(source).forEach(key => {\\n    copy[key] = deepCopy(source[key])\\n  })\\n  return copy\\n}\\n```\\n`JSON.parse(JSON.stringify(source))` 是对深拷贝的实现\\n\\n但存在如下问题：\\n\\n *  拷贝JSON中不支持的类型会有问题，如`Date`类型拷贝时，会转化为带T格式的日期字符串\",\"__v\":0},{\"_id\":\"5c2a1441b042777d45a5859d\",\"meta\":{\"createDate\":\"2018-12-31 21:06:09\",\"updateDate\":\"2019-05-05 14:20:49\"},\"tags\":[\"笔记\"],\"title\":\"Centos6.8下安装jenkins\",\"content\":\"本博客使用了jenkins进行持续集成，在配置腾讯云时，顺便记录下配置过程。安装jenkins的方式[官网](https://jenkins.io/doc/book/installing/) 给出了多种，这里使用了war包文件方式安装。\\n\\n## 一、安装前提\\n\\n### 1、安装java1.8版本\\n\\nJenkins 依赖于1.8版本的java。\\n\\n使用yum，安装java1.8，执行\\n\\n```shell\\nyum install -y java-1.8.0-openjdk.x86_64\\n```\\n\\n安装以后执行 `java -version` 看下是否安装成功。\\n\\n### 2、添加环境变量\\n\\n接着在 /etc/profile文件里添加java的环境变量\\n\\n```shell\\nvim  /etc/profile\\n```\\n\\n在最后添加如下代码：\\n\\n```\\nJAVA_HOME=/usr/java/jdk1.8.0_74\\nJRE_HOME=/usr/java/jdk1.8.0_74/jre\\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\\nCLASSPATH=:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\\n```\\n\\n执行修改生效命令：`source /etc/profile`\\n\\n查看是否生效命令：`echo $PATH`\\n\\n## 二、jenkins相关\\n\\n### 1、下载jenkins war包\\n\\njava安装的准备工作做完了，接着根据[官网](https://pkg.jenkins.io/redhat/)提供的Centos下的jenkins下载方式，执行如下命令：\\n\\n```shell\\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat/jenkins.repo\\nsudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\\n```\\n\\n找到刚下载的安装包，可执行如下命令：\\n\\n`rpm -ql jenkins`\\n\\n结果如下：\\n\\n```shell\\n[root@VM_160_98_centos ~]# rpm -ql jenkins\\n/etc/init.d/jenkins\\n/etc/logrotate.d/jenkins\\n/etc/sysconfig/jenkins\\n/usr/lib/jenkins\\n/usr/lib/jenkins/jenkins.war\\n/usr/sbin/rcjenkins\\n/var/cache/jenkins\\n/var/lib/jenkins\\n/var/log/jenkins\\n```\\n\\n`/usr/lib/jenkins/jenkins.war`就是war包的位置了。\\n\\n### 2、默认启动端口\\n\\n这里先顺便修改下jenkins的8080默认启动端口。(查看端口使用情况命令：`netstat -ntlp`)\\n\\n修改端口的文件命令为：`vim /etc/sysconfig/jenkins`，找到里面的`JENKINS_PORT=\\\"8080\\\"`，我这里改为了5555，没需求可不修改。\\n\\n### 3、运行jenkins\\n\\n运行jenkins命令且退出命令行不影响程序执行，运行如下命令：\\n\\n`java -jar /usr/lib/jenkins/jenkins.war --httpPort=5555 &`\\n\\n其中 `&` 符号使得退出命令行不影响程序执行。\\n\\n### 4、添加nginx 代理端口设置\\n\\n接着在nginx里配置代理到5555端口，使得外网能访问。\\n\\n接着到服务器后台管理（我服务器是腾讯云）添加子域名和在安全组里添加5555端口的入站规则。\\n\\n这样jenkins就算安装完成了。[http://jenkins.tanxchen.com](http://jenkins.tanxchen.com)\\n\\n## 附：Jenkins 默认插件\\n\\n![默认插件](https://gitee.com/tanxchen/img/raw/master/blog/jenkins-default-plugin-ls.jpg)\\n\\n* Floders Plugin\\n* OWASP markup formatter plugin\\n* Build timeout plugin\\n* Credentials binding plugin\\n* timestamper\\n* Workspace cleanup plugin\\n* ant plugin\\n* Gradle plugin\\n* pipeline\\n* Github organization floder plugin\\n* pipeline stage view plugin\\n* Git plugin\\n* subversion plugin\\n* SSH slaves plugin\\n* Matrix authorization stragegy plugin\\n* PAM authentication plugin\\n* LDAP plugin\\n* Email extension plugin\\n* Mailer plugin\\n\\n共19个默认插件\\n\\n\",\"__v\":1}]");

/***/ }),

/***/ 44:
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(50);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add CSS to SSR context
var add = __webpack_require__(4).default
module.exports.__inject__ = function (context) {
  add("9156c51a", content, true, context)
};

/***/ }),

/***/ 49:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_stylus_loader_index_js_ref_8_oneOf_1_3_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_98330b66_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_stylus_loader_index_js_ref_8_oneOf_1_3_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_98330b66_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_stylus_loader_index_js_ref_8_oneOf_1_3_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_98330b66_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_stylus_loader_index_js_ref_8_oneOf_1_3_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_98330b66_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_stylus_loader_index_js_ref_8_oneOf_1_3_node_modules_nuxt_components_dist_loader_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_style_index_0_id_98330b66_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),

/***/ 50:
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(3);
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(false);
// Module
___CSS_LOADER_EXPORT___.push([module.i, ".desc[data-v-98330b66]{height:64px;box-sizing:border-box;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.desc[data-v-98330b66] *{margin:0!important;line-height:24px!important;font-size:16px!important;font-weight:400!important;padding:0!important;border:0!important}", ""]);
// Exports
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ 53:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./pages/index.vue?vue&type=template&id=98330b66&scoped=true&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{staticClass:"container"},[_c('bl-header'),_vm._ssrNode(" "),_vm._l((_vm.articles),function(article,index){return _vm._ssrNode("<div class=\"post\" data-v-98330b66>","</div>",[_vm._ssrNode("<h1 class=\"post-title\" data-v-98330b66>","</h1>",[_c('NuxtLink',{attrs:{"to":{ path: ("/article/" + (article._id)) }}},[_vm._v("\n        "+_vm._s(article.title)+"\n      ")])],1),_vm._ssrNode(" <div class=\"post-meta\" data-v-98330b66>"+_vm._ssrEscape(_vm._s(article.meta.createDate))+"</div> <div class=\"post-content mdcontent desc\" data-v-98330b66>"+(_vm._s(article.content))+"</div> "),_vm._ssrNode("<p class=\"readmore\" data-v-98330b66>","</p>",[_c('NuxtLink',{attrs:{"to":{ path: ("/article/" + (article._id)) }}},[_vm._v("阅读全文")])],1)],2)})],2)}
var staticRenderFns = []


// CONCATENATED MODULE: ./pages/index.vue?vue&type=template&id=98330b66&scoped=true&

// EXTERNAL MODULE: ./plugins/markdown.js
var markdown = __webpack_require__(40);

// EXTERNAL MODULE: ./components/Header.vue + 4 modules
var Header = __webpack_require__(9);

// EXTERNAL MODULE: ./data/articles.json
var articles = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--2-0!./node_modules/@nuxt/components/dist/loader.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./pages/index.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// import axios from '~/plugins/axios'



/* harmony default export */ var lib_vue_loader_options_pagesvue_type_script_lang_js_ = ({
  name: 'Index',
  components: {
    BlHeader: Header["default"]
  },

  async asyncData() {
    // let { data } = await axios.get('/api/articles')
    let data = articles;

    if (Array.isArray(data)) {
      data.forEach(article => {
        article.content && (article.content = markdown["a" /* default */].render(article.content));
      });
    }

    return {
      articles: data
    };
  },

  mounted() {
    if (document.title !== 'TanxChen\'blog') {
      document.title = 'TanxChen\'blog';
    }
  }

});
// CONCATENATED MODULE: ./pages/index.vue?vue&type=script&lang=js&
 /* harmony default export */ var pagesvue_type_script_lang_js_ = (lib_vue_loader_options_pagesvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(2);

// CONCATENATED MODULE: ./pages/index.vue



function injectStyles (context) {
  
  var style0 = __webpack_require__(49)
if (style0.__inject__) style0.__inject__(context)

}

/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  pagesvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  injectStyles,
  "98330b66",
  "ab61fc96"
  
)

/* harmony default export */ var pages = __webpack_exports__["default"] = (component.exports);

/***/ })

};;
//# sourceMappingURL=index.js.map